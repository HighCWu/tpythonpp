##TPython Main Header - becomes tp.gen.h

#ifndef TP_H
#define TP_H

#ifdef USE_EMBEDDED_BYTECODE
  import "__user_bytecode__.gen.h"
#endif

import "blendot/vector2.h"
import "blendot/vector3.h"
import "blendot/quat.h"
import "blendot/color.h"
import "blendot/rect2.h"
import "blendot/face3.h"
import "blendot/plane.h"
import "blendot/basis.h"
import "blendot/aabb.h"
import "blendot/transform.h"
import "blendot/rid.h"
import "blendot/scene/3d/spatial.h"
import "blendot/scene/resources/mesh.h"
import "blendot/scene/3d/mesh_instance.h"


import <cstddef>

#ifdef INCLUDEOS
  import <os>
  #ifdef INCLUDEOS_VGA
    import <vga>
    import <hw/ps2.hpp>
  #endif
  #ifdef INCLUDEOS_SVGA
    import <hw/ps2.hpp>
    import <hw/vga_gfx.hpp>
  #endif
#else
  import <dlfcn.h>
  static void* __libself__ = NULL
#endif

import <functional>
import <algorithm>
import <map>
import <string>
import <iostream>
import <sstream>
import <cstring>

import <setjmp.h>
import <sys/stat.h>
#ifndef __USE_ISOC99
  #define __USE_ISOC99
#endif

import <stdio.h>
import <stdlib.h>
import <string.h>
import <stdarg.h>
import <math.h>
import <time.h>

## better performance when the compiler is allowed to making the inline decisions
## PGO has no speed up when tp_inline is defined. So here it is defined as nothing.
#define tp_inline

## FIXME: increased so that gc doesnt get called while running tp_str()
#ifdef INCLUDEOS
  //#define TP_GCMAX 16384
  #define TP_GCMAX 262144
#else
  #define TP_GCMAX 524288
#endif

#define TP_REGS 16384

// fixes bench marking test, might need to be set higher later
//#define TP_GCMAX 65536  // still not enough for heavy loads
//#define TP_GCMAX 2097152  // this is too much with threads

//#define TP_REGS 32768  // not required

#define TP_FRAMES 256
#define TP_REGS_EXTRA 2
/* #define TP_REGS_PER_FRAME 256*/

enum TPTypeID {
  TP_NONE = 0,
  TP_NUMBER = 1,
  TP_INTEGER = 2,
  TP_VEC2 = 3,
  TP_VEC3 = 4,
  TP_QUAT = 5,
  TP_COLOR = 6,
  TP_RECT = 7,
  TP_TRI = 8,
  TP_PLANE = 9,
  TP_AABB = 10,
  TP_MAT3 = 11,
  TP_TRANS = 12,
  TP_RID   = 13,
  TP_SPATIAL = 14,
  TP_MESH    = 15,
  TP_MESHI   = 16,

  TP_GC_TRACKED = 32,
  TP_FUNC = 33,
  TP_DATA = 34,

  TP_HAS_META = 99,     // this is not a type, any type >= TP_HAS_META can have a metatype
  TP_STRING = 100,
  TP_LIST = 101,
  TP_DICT = 102,
  TP_OBJECT = 103,
  TP_INTERFACE = 104,
};

typedef struct TPTypeInfo {
  enum TPTypeID type_id : 32;
  unsigned int magic: 32;
} TPTypeInfo;

enum TPFuncMagic {
  TP_FUNC_MASK_C = 1,
  TP_FUNC_MASK_METHOD = 2,
  TP_FUNC_MASK_CPP = 100,
  TP_FUNC_MASK_METHOD_CPP = 101,
};

enum TPStringMagic {
  TP_STRING_NONE = 0,
  TP_STRING_ATOM = 1,
  TP_STRING_EXTERN = 2,
  TP_STRING_VIEW = 3,
};

typedef double tp_num;
//typedef long double tp_num;


/* Type: tp_obj
 * Tinypys object representation.
 * 
 * Every object in tinypy is of this type in the C API.
 *
 * Fields:
 * type - This determines what kind of objects it is. It is either TP_NONE, in
 *        which case this is the none type and no other fields can be accessed.
 *        Or it has one of the values listed below, and the corresponding
 *        fields can be accessed.
 * number - TP_NUMBER
 * number.val - A double value with the numeric value.
 * string - TP_STRING
 * string.val - A pointer to the string data.
 * string.len - Length in bytes of the string data.
 * dict - TP_DICT
 * list - TP_LIST
 * func - TP_FUNC
 * data - TP_DATA
 * data.val - The user-provided data pointer.
 * type.magic - The user-provided magic number for identifying the data type.
 */

// https://stackoverflow.com/questions/12094694/c-union-vs-class-inheritance
// https://stackoverflow.com/questions/3615001/why-union-cant-be-used-in-inheritance
// https://stackoverflow.com/questions/34075606/using-inheritance-within-a-union/34076227


struct tp_vm;

typedef class tp_obj {
 public:
  tp_obj(){};
  tp_obj(TPTypeID t){ type.type_id=t; };
  union {
  TPTypeInfo type;
  struct { TPTypeInfo type; int * gci; } gc;
  struct { TPTypeInfo type; tp_num val; } number;
  struct { TPTypeInfo type; int val; } integer;
  struct { TPTypeInfo type; struct tpd_func *info; void *cfnc;} func;
  struct { TPTypeInfo type; struct tpd_data *info; void *val; } data;
  struct { TPTypeInfo type; struct tpd_obj *info; } obj;  // what type of object is this?
  struct { TPTypeInfo type; struct tpd_list *val; } list;
  struct { TPTypeInfo type; struct tpd_dict *val; } dict;
  struct { TPTypeInfo type; struct tpd_dict *val; } object;
  struct { TPTypeInfo type; struct tpd_dict *val; } interface;
  struct { TPTypeInfo type; struct tpd_string *info; const char * val;} string;
  struct { TPTypeInfo type; struct Vector2 vec; } vec2;
  struct { TPTypeInfo type; struct Vector3 vec; } vec3;
  struct { TPTypeInfo type; struct Quat q; } quat;
  struct { TPTypeInfo type; struct Color c; } color;
  struct { TPTypeInfo type; struct Rect2 r; } rect;
  struct { TPTypeInfo type; struct Face3 t; } tri;
  struct { TPTypeInfo type; struct Plane p; } plane;
  struct { TPTypeInfo type; struct AABB a; } aabb;
  struct { TPTypeInfo type; struct Basis m; } mat3;
  struct { TPTypeInfo type; struct Transform t; } trans;
  struct { TPTypeInfo type; struct RID r; } rid;
  struct { TPTypeInfo type; struct Spatial *ptr; } spatial;
  struct { TPTypeInfo type; struct ArrayMesh *ptr; } mesh;
  struct { TPTypeInfo type; struct MeshInstance *ptr; } meshi;
 };
//tp_obj(double num) {
//this->type.type_id = TP_NUMBER;
//this->number.val = num;
//}
 bool operator==(const char* s) const;
 operator char() const;
 operator uint8_t() const;
 tp_obj operator[] (int index);
 tp_obj operator+ (const tp_obj & first) const {
  tp_obj val = {TP_NUMBER};
  val.number.val = this->number.val + first.number.val;
  return val;
 }
 tp_obj operator- (const tp_obj & first) const {
  tp_obj val = {TP_NUMBER};
  val.number.val = this->number.val - first.number.val;
  return val;
 }
 tp_obj operator* (const tp_obj & first) const {
  tp_obj val = {TP_NUMBER};
  val.number.val = this->number.val * first.number.val;
  return val;
 }
 tp_obj operator/ (const tp_obj & first) const {
  tp_obj val = {TP_NUMBER};
  val.number.val = this->number.val / first.number.val;
  return val;
 }
 friend std::ostream & operator << (std::ostream &out, const tp_obj &self);
 void append(const char *s);
 void append(std::string s);
 void append(double n);
 void append(int n);
 void append(tp_obj ob);
} tp_obj;


/*
Functions are into several namespaces from lower-level to higher-level:

- `tpd_*` : tinypy data structures;

- `tp_*` : tinypy interpreter C-API;
		   arguments from C arguments;
		   functions may return any C value;
		   return values are usually tracked by gc,
		   unless the name indicates untracked (ending with _nt)
		   add the result to gc before dropping to the Python land.

- `tpy_*` : python language C-API
			arguments from local scope parameter list
			functions always return tp_obj;
			return values are usually tracked by gc if it should,
			unless the name indicates untracked.

*/

typedef struct tpd_obj {
  int gci;
  tp_obj meta;
} tpd_obj;

typedef struct tpd_string {
  int gci;
  tp_obj meta;
  tp_obj base;
  char * s;
  int len;
} tpd_string;

typedef struct tpd_list {
  int gci;
  tp_obj meta;
  tp_obj *items;
  int len;
  int alloc;
} tpd_list;

typedef struct tpd_item {
  int used;
  int hash;
  tp_obj key;
  tp_obj val;
} tpd_item;

typedef struct tpd_dict {
  int gci;
  tp_obj meta;
  tpd_item *items;
  int len;
  int alloc;
  int cur;
  int mask;
  int used;
} tpd_dict;

typedef struct tpd_func {
  int gci;
  tp_obj instance;
  tp_obj globals;
  tp_obj code;
  std::function<tp_obj(tp_vm*)> cppfunc;
} tpd_func;

typedef union tpd_code {
  unsigned char i;
  struct { unsigned char i,a,b,c; } regs;
  struct { char val[4]; } string;
  struct { float val; } number;
} tpd_code;

typedef struct tpd_frame {
  tp_obj code;
  tpd_code *cur;
  tpd_code *jmp;
  tp_obj *regs;
  tp_obj *ret_dest;
  tp_obj fname;
  tp_obj name;
  tp_obj line;
  tp_obj globals;
  int lineno;
  int cregs;
  //tp_obj __fast_locals__[256] = {};
  //int __const_ints__[64] = {};
} tpd_frame;



/* Type: tp_vm
 * Representation of a tinypy virtual machine instance.
 * 
 * A new tp_vm struct is created with <tp_init>, and will be passed to most
 * tinypy functions as first parameter. It contains all the data associated
 * with an instance of a tinypy virtual machine - so it is easy to have
 * multiple instances running at the same time. When you want to free up all
 * memory used by an instance, call <tp_deinit>.
 * 
 * Fields:
 * These fields are currently documented: 
 * 
 * builtins - A dictionary containing all builtin objects.
 * modules - A dictionary with all loaded modules.
 * params - A list of parameters for the current function call.
 * frames - A list of all call frames.
 * cur - The index of the currently executing call frame.
 * frames[n].globals - A dictionary of global sybmols in callframe n.
 */
static tp_obj __string_meta__;

typedef struct tp_vm {
  tp_obj builtins;
  tp_obj modules;
  tp_obj _list_meta;
  tp_obj _dict_meta;
  //tp_obj _string_meta;
  tpd_frame frames[TP_FRAMES];
  tp_obj _params;
  tp_obj params;
  tp_obj _regs;
  tp_obj *regs;
  tp_obj root;
  jmp_buf buf;
  #ifdef CPYTHON_MOD
    jmp_buf nextexpr;
  #endif
  int jmp;
  tp_obj ex;
  tp_obj last_result;
  char chars[256][2];
  int cur;
  void (*echo)(const char* data, int length);
  ## gc ##
  tpd_list *white;
  tpd_list *grey;
  tpd_list *black;
  int steps;
  ## sandbox ##
  clock_t clocks;
  double time_elapsed;
  double time_limit;
  unsigned long mem_limit;
  unsigned long mem_used;
  int mem_exceeded;
} tp_vm;

#define TP tp_vm *tp

typedef struct tpd_data {
  int gci;
  void (*free)(TP,tp_obj);
} tpd_data;

#define tp_True tp_number(1)
#define tp_False tp_number(0)
#define True tp_number(1)
#define False tp_number(0)

extern tp_obj tp_None;
#define None tp_None

#ifdef TP_SANDBOX
void *tp_malloc(TP, unsigned long);
void *tp_realloc(TP, void *, unsigned long);
void tp_free(TP, void *);
#else
#define tp_malloc(TP,x) calloc((x),1)
#define tp_realloc(TP,x,y) realloc(x,y)
#define tp_free(TP,x) free(x)
#endif

def tp_sandbox(TP, double, unsigned long);
def tp_time_update(TP);
def tp_mem_update(TP);

def tp_track(TP, tp_obj)->tp_obj;
def tp_grey(TP,tp_obj);

/* __func__ __VA_ARGS__ __FILE__ __LINE__ */

/* Function: tp_raise
 * Macro to raise an exception.
 * 
 * This macro will return from the current function returning "r". The
 * remaining parameters are used to format the exception message.
 */
def _tp_raise(TP,tp_obj);

#define tp_raise(r, obj) { \
	_tp_raise(tp, obj); \
	return r; \
}

#define tp_raise_printf(r,fmt,...) { \
	_tp_raise(tp, tp_printf(tp, fmt, __VA_ARGS__)); \
	return r; \
}

/* Function: tp_string_from_const
 * Creates a new string object from a C string.
 * 
 * Given a pointer to a C string, creates a tinypy object representing the
 * same string.
 * 
 * *Note* Only a reference to the string will be kept by tinypy, so make sure
 * it does not go out of scope, and dont de-allocate it. Also be aware that
 * tinypy will not delete the string for you. In many cases, it is best to
 * use <tp_string_t> or <tp_string_slice> to create a string where tinypy
 * manages storage for you.
 */

def tp_string_atom(TP, const char * v)->tp_obj;

def tp_string_len(tp_obj s) ->int;

def tp_string_getptr(tp_obj s) ->char*;

def tp_string_t(TP, int n)->tp_obj;

## Function: tp_cstr
## Fill a C string from a tinypy string, and return as a buffer
## that needs to be freed by tp_free
def tp_cstr(TP, tp_obj v) ->char*;


@static
def tp_check_type(TP, int t, tp_obj v) -> tp_obj:
	if v.type.type_id != t:
		tp_raise(
		  tp_None,
		  tp_string_atom(tp, "(tp_check_type) TypeError: unexpected type"))
	return v


## Macros for obtaining objects from the parameter list of the current
## function scope.

#define TP_NO_LIMIT 0
#define TP_OBJ() (tp_get(tp, tp->params, tp_None))
#define TP_TYPE(t) tp_check_type(tp, t, TP_OBJ())
#define TP_NUM() (TP_TYPE(TP_NUMBER).number.val)
#define TP_STR() (TP_TYPE(TP_STRING))
#define TP_DEFAULT(d) (tp->params.list.val->len?tp_get(tp, tp->params, tp_None):(d))

/* Macro: TP_LOOP
 * Macro to iterate over all remaining arguments.
 *
 * If you have a function which takes a variable number of arguments, you can
 * iterate through all remaining arguments for example like this:
 *
 * > tp_obj *my_func(tp_vm *tp)
 * > {
 * >     // We retrieve the first argument like normal.
 * >     tp_obj first = TP_OBJ();
 * >     // Then we iterate over the remaining arguments.
 * >     tp_obj arg;
 * >     TP_LOOP(arg)
 * >         // do something with arg
 * >     TP_END
 * > }
 */
def tpd_list_get(TP, tpd_list *self, int k, const char *error)->tp_obj;

#define TP_LOOP(e) \
int __l = tp->params.list.val->len; \
int __i; for (__i=0; __i<__l; __i++) { \
(e) = tpd_list_get(tp, tp->params.list.val, __i, "TP_LOOP");
#define TP_END }

## Function: tp_number
## Creates a new numeric object.

@static
def tp_number(tp_num v) -> tp_obj:
	tp_obj val = {TP_NUMBER};
	val.number.val = v
	return val

@static
def tp_integer(int v) -> tp_obj:
	tp_obj val = {TP_INTEGER};
	val.integer.val = v
	return val

@static
def tp_vec2(double x, double y) -> tp_obj:
	tp_obj val = {TP_VEC2};
	val.vec2.vec.x = x
	val.vec2.vec.y = y
	return val

@static
def tp_vec3(double x, double y, double z) -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.vec3.vec.x = x
	val.vec3.vec.y = y
	val.vec3.vec.z = z
	return val

@static
def tp_vec3(Vector3 v) -> tp_obj:
	tp_obj val = {TP_VEC3};
	val.vec3.vec = v
	return val

@static
def tp_quat(double x, double y, double z, double w) -> tp_obj:
	tp_obj val = {TP_QUAT};
	val.quat.q.x = x
	val.quat.q.y = y
	val.quat.q.z = z
	val.quat.q.w = w
	return val

@static
def tp_color(double r, double g, double b, double a) -> tp_obj:
	tp_obj val = {TP_COLOR};
	val.color.c.r = r
	val.color.c.g = g
	val.color.c.b = b
	val.color.c.a = a
	return val

@static
def tp_rect(double x, double y, double w, double h) -> tp_obj:
	tp_obj val = {TP_RECT};
	val.rect.r = Rect2(x,y,w,h)
	return val

@static
def tp_tri(Vector3 a, Vector3 b, Vector3 c) -> tp_obj:
	tp_obj val = {TP_TRI};
	val.tri.t = Face3(a,b,c)
	return val

@static
def tp_plane(Vector3 normal, double length) -> tp_obj:
	tp_obj val = {TP_PLANE};
	val.plane.p = Plane(normal, length)
	return val

@static
def tp_aabb(Vector3 pos, Vector3 size) -> tp_obj:
	tp_obj val = {TP_AABB};
	val.aabb.a = AABB(pos,size)
	return val


@static
def tp_mat3(Vector3 a, Vector3 b, Vector3 c) -> tp_obj:
	tp_obj val = {TP_MAT3};
	val.mat3.m = Basis(a,b,c)
	return val

@static
def tp_trans(Basis b, Vector3 origin) -> tp_obj:
	tp_obj val = {TP_TRANS};
	val.trans.t = Transform(b, origin)
	return val

@static
def tp_rid(int id) -> tp_obj:
	tp_obj val = {TP_RID};
	val.rid.r = RID(id)
	return val

@static
def tp_spatial(Vector3 pos, Vector3 rot, Vector3 scl) -> tp_obj:
	tp_obj val = {TP_SPATIAL};
	val.spatial.ptr = new Spatial()
	val.spatial.ptr->set_translation(pos)
	val.spatial.ptr->set_rotation_degrees(rot)
	val.spatial.ptr->set_scale(scl)
	return val

@static
def tp_mesh() -> tp_obj:
	tp_obj val = {TP_MESH};
	val.mesh.ptr = new ArrayMesh()
	return val


/* Function: tp_string_from_const (was tp_string_n)
 * Creates a new string object from a partial C string.
 * 
 * Like <tp_string>, but you specify how many bytes of the given C string to
 * use for the string object. The *note* also applies for this function, as the
 * string reference and length are kept, but no actual substring is stored.
 */

@static
def tp_string_from_const(TP, char const * v, int n)->tp_obj;

def tp_string_from_stdstring(TP, std::string s)->tp_obj;


def tp_params(TP)->tp_obj;
def tp_params_n(TP, int n, tp_obj argv[])->tp_obj;
def tp_params_v(TP, int n, ...)->tp_obj;

def tp_import(TP, tp_obj name, tp_obj code, tp_obj fname)->tp_obj;

def tp_import_from_buffer_with_filename(TP, const char * fname, const char * name, void *codes, int len)->tp_obj;
def tp_import_from_buffer(TP, const char * name, unsigned char *codes, int len)->tp_obj;


def tp_ez_call(TP, const char *mod, const char *func, tp_obj params)->tp_obj;
def tp_eval_from_cstr(TP, const char *text, tp_obj globals)->tp_obj;
def tp_exec(TP, tp_obj code, tp_obj globals)->tp_obj;
def tp_compile(TP, tp_obj text, tp_obj fname)->tp_obj;

def tp_data_t(TP, int magic, void *v)->tp_obj;
def tp_data(TP, int magic, void *v)->tp_obj;

def tp_len(TP,tp_obj self)->tp_obj;
def len(tp_obj ob)->int;

def tp_list_t(TP)->tp_obj;
#define tp_list tp_list_t

def tp_list_nt(TP)->tp_obj;
def tpd_list_append(TP,tpd_list *self, tp_obj v);

def tp_dict_t(TP)->tp_obj;
def tp_dict(TP)->tp_obj;

def tpd_dict_new(TP) ->tpd_dict*;

def tp_object_t(TP)->tp_obj;
#define tp_object tp_object_t
def tp_dict_nt(TP)->tp_obj;

def tp_function(TP, tp_obj v(TP))->tp_obj;

## note: when this is used from user c++, the lamba must capture by `[=]`
## the pointer to self, it is up to the user to delete the pointer later.
def tp_function(TP, std::function<tp_obj(tp_vm*)>) ->tp_obj;

def tp_method(TP, tp_obj self,tp_obj v(TP)) ->tp_obj;

## note: if below is used for user defined c++ classes,
## the data members of those class instances will be lost on the `self` below,
## because when created on the stack, those members are lost when passed to another function
## TODO capture `self` as a pointer instead for this case.
def tp_method(TP, tp_obj self, std::function<tp_obj(tp_vm*)>) ->tp_obj;

def tp_def(TP, tp_obj code, tp_obj g) ->tp_obj;
def tp_bind(TP, tp_obj function, tp_obj self)->tp_obj;

def tp_printf(TP, const char * fmt, ...)->tp_obj;

def tp_init(int argc, char *argv[]) ->tp_vm*;
def tp_deinit(TP);

def tp_module_sys_init(TP, int argc, char * argv[]);
def tp_module_builtins_init(TP);
def tp_module_compiler_init(TP);
def tp_module_corelib_init(TP);


@static
def tp_as_string(TP, tp_obj self) ->std::string:
	std::stringstream ss
	int type = self.type.type_id
	switch type:
		case TP_STRING:
			if self.type.magic == TP_STRING_VIEW:
				#ifdef DEBUG
				  std::cout << "STRING VIEW" << std::endl;
				#endif
				ss << "\"" << tp_as_string(tp, self.string.info->base) << "\""
			else:
				if self.type.magic == TP_STRING_ATOM:
					//std::cout << "STRING ATOM" << std::endl;
					ss << "\"" << self.string.val << "\"";
				elif self.type.magic == TP_STRING_EXTERN:
					//std::cout << "STRING EXTERN" << std::endl;
					ss << "\"" << self.string.info->s << "\"";
				else:
					//std::cout << "STRING TYPE" << std::endl;
					ss << "\"" << self.string.info->s << "\"";
			break
		case TP_INTEGER: ss << self.integer.val; break;
		case TP_NUMBER: ss << self.number.val; break;
		case TP_NONE: ss << "None"; break;
		case TP_FUNC: ss << "function<" << self.func.cfnc << ">"; break;
		case TP_LIST:
			ss << "["
			for (int i=0; i<self.list.val->len; i++):
				ss << tp_as_string(tp, self.list.val->items[i]) << ","
			ss << "]"
			break
		case TP_DICT:
			ss << "{"
			for (int i=0; i<self.dict.val->len; i++):
				tpd_item item = self.dict.val->items[i]
				ss << tp_as_string(tp, item.key) << ":"
				ss << tp_as_string(tp, item.val)
				ss << ","
			ss << "}"
			break
		case TP_OBJECT:
			ss << "object<" << self.object.val << ">"
			break
		case TP_INTERFACE:
			ss << "interface<" << self.interface.val << ">"
			break
		case TP_DATA:
			ss << "data<" << self.data.val << ">"
			break
		case TP_VEC2:
			ss << "vec2( x=" << self.vec2.vec.x << ", y=" << self.vec2.vec.y << ")"
			break
		case TP_VEC3:
			ss << "vec3( x=" << self.vec3.vec.x << ", y=" << self.vec3.vec.y << ", z=" << self.vec3.vec.z << ")"
			break
		case TP_QUAT:
			ss << "quat( x=" << self.quat.q.x << ", y=" << self.quat.q.y << ", z=" << self.quat.q.z << ", w=" << self.quat.q.w << ")"
			break
		case TP_COLOR:
			ss << "color( red=" << self.color.c.r << ", green=" << self.color.c.g << ", blue=" << self.color.c.b << ", alpha=" << self.color.c.a << ")"
			break
		case TP_RECT:
			ss << "rect( x=" << self.rect.r.position.x << ", y=" << self.rect.r.position.y << ", width=" << self.rect.r.size.x << ", height=" << self.rect.r.size.y << ")"
			break
		case TP_TRI:
			ss << "tri(" << std::endl
			ss << "	a:  x=" << self.tri.t.vertex[0].x << ", y=" << self.tri.t.vertex[0].y << ", z=" << self.tri.t.vertex[0].z << std::endl
			ss << "	b:  x=" << self.tri.t.vertex[1].x << ", y=" << self.tri.t.vertex[1].y << ", z=" << self.tri.t.vertex[1].z << std::endl
			ss << "	c:  x=" << self.tri.t.vertex[2].x << ", y=" << self.tri.t.vertex[2].y << ", z=" << self.tri.t.vertex[2].z << std::endl
			ss << ")"
			break
		case TP_PLANE:
			ss << "plane(" << std::endl
			ss << "	normal:  x=" << self.plane.p.normal.x << ", y=" << self.plane.p.normal.y << ", z=" << self.plane.p.normal.z << std::endl
			ss << "	length:  " << self.plane.p.d << std::endl
			ss << ")"
			break
		case TP_AABB:
			ss << "aabb(" << std::endl
			ss << "	position:  x=" << self.aabb.a.position.x << ", y=" << self.aabb.a.position.y << ", z=" << self.aabb.a.position.z << std::endl
			ss << "	size:  x=" << self.aabb.a.size.x << ", y=" << self.aabb.a.size.y << ", z=" << self.aabb.a.size.z << std::endl
			ss << ")"
			break
		case TP_MAT3:
			ss << "mat3(" << std::endl
			ss << "	" << self.mat3.m.elements[0].x << ", " << self.mat3.m.elements[0].y << ", " << self.mat3.m.elements[0].z << std::endl
			ss << "	" << self.mat3.m.elements[1].x << ", " << self.mat3.m.elements[1].y << ", " << self.mat3.m.elements[1].z << std::endl
			ss << "	" << self.mat3.m.elements[2].x << ", " << self.mat3.m.elements[2].y << ", " << self.mat3.m.elements[2].z << std::endl
			ss << ")"
			break
		case TP_TRANS:
			ss << "transform(" << std::endl
			ss << "	vec3( x=" << self.trans.t.origin.x << ", y=" << self.trans.t.origin.y << ", z=" << self.trans.t.origin.z << ")"  << std::endl
			ss << "	mat3(" << std::endl
			ss << "		" << self.trans.t.basis.elements[0].x << ", " << self.trans.t.basis.elements[0].y << ", " << self.trans.t.basis.elements[0].z << std::endl
			ss << "		" << self.trans.t.basis.elements[1].x << ", " << self.trans.t.basis.elements[1].y << ", " << self.trans.t.basis.elements[1].z << std::endl
			ss << "		" << self.trans.t.basis.elements[2].x << ", " << self.trans.t.basis.elements[2].y << ", " << self.trans.t.basis.elements[2].z << std::endl
			ss << "	)" << std::endl
			ss << ")"
			break
		case TP_RID:
			ss << "RID( id=" << self.rid.r.get_id() << ")"
			break
		case TP_SPATIAL:
			Vector3 pos = self.spatial.ptr->get_translation()
			Vector3 rot = self.spatial.ptr->get_rotation_degrees()
			Vector3 scl = self.spatial.ptr->get_scale()
			ss << "spatial(" << std::endl
			ss << "	addr:		" << self.spatial.ptr << std::endl
			ss << "	position:	x=" << pos.x << ", y=" << pos.y << ", z=" << pos.z << std::endl
			ss << "	rotation:	x=" << rot.x << ", y=" << rot.y << ", z=" << rot.z << std::endl
			ss << "	scale:		x=" << scl.x << ", y=" << scl.y << ", z=" << scl.z << std::endl
			ss << ")"
			break
		default:
			ss << "<unknown type>"
	return ss.str()


def tp_get_by_char(TP, tp_obj d, char c)->tp_obj;
def tp_set_by_char(TP, tp_obj d, char c, tp_obj v);

## python-style print helper funcs ##

@static
def print(const char *s):
	std::cout << s << std::endl;

@static
def print(tp_obj ob):
	std::cout << ob << std::endl;

@static
def print(double num):
	std::cout << num << std::endl;

@static
def print(int num):
	std::cout << num << std::endl;

@static
def print(std::string s):
	std::cout << s << std::endl;

@static
def print(void* v):
	std::cout << v << std::endl;

#ifndef INCLUDEOS
@static
def __init_libself__():
	__libself__=dlopen(NULL, 1)
	#ifdef DEBUG
	print(__libself__)
	#endif

#endif

import "tp_ops.gen.h"

#endif
