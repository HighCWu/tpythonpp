__is_ode_init = False
static dWorldID __world__
static bool __has_contacts__ = false
static dJointGroupID __contactgroup__

@static
def __nearCallback(void* ptr, dxGeom* o1, dxGeom* o2) ->void:
	global __has_contacts__
	print("nearCallback...")
	print(o1)
	print(o2)
	#b1 = dGeomGetBody(o1)  ## wants an int id
	#b2 = dGeomGetBody(o2)
	b1 = o1->body
	b2 = o2->body
	const int N = 10
	dContact cons[N]
	for i in range(N):
		cons[i].surface.mode = dContactSoftCFM | dContactApprox1
		cons[i].surface.mu   = 0.5
		cons[i].surface.soft_cfm = 0.01
	hits = dCollide(o1, o2, N, &cons[0].geom, sizeof(dContact))
	if hits > 0:
		__has_contacts__ = true
		for i in range( hits ):
			coj = dJointCreateContact(__world__, __contactgroup__, cons+i)
			dJointAttach(coj, b1, b2)


class world( object ):
	def __wpointer__(self) ->dxWorld*:
		return unwrap(dxWorld, self.__wptr__)
	def setGravity(self, v):
		dWorldSetGravity( self.__wpointer__(), v[0], v[1], v[2] )
	def step(self, dt):
		dWorldStep( unwrap(dxWorld, self.__wptr__), dt )
	def __init__(self):
		global __is_ode_init, __world__
		if not __is_ode_init:
			dInitODE()
			__is_ode_init = True
			__world__ = dWorldCreate()
			self.__wptr__ = __world__
			__contactgroup__ = dJointGroupCreate(0)
		else:
			print("only a single ODE world is allowed for now")

class mass( object ):
	def __mpointer__(self) ->dMass*:
		return unwrap(dMass, self.__mptr__)
	def setSphere(self, density, radius):
		dMassSetSphere( self.__mpointer__(), density, radius )
	def __init__(self):
		self.__mptr__  = new dMass()

class body( object ):
	def __bpointer__(self) ->dxBody*:
		return unwrap(dxBody, self.__bptr__)
	def setMass(self, mass):
		dBodySetMass( self.__bpointer__(), mass.__mpointer__() )
	def setPosition(self, v):
		dBodySetPosition( self.__bpointer__(), v[0],v[1],v[2] )
	def addForce(self, vec):
		dBodyAddForce( self.__bpointer__(), vec[0], vec[1], vec[2] )
	def addRelForce(self, vec):
		dBodyAddRelForce( self.__bpointer__(), vec[0], vec[1], vec[2] )
	def addTorque(self, vec):
		dBodyAddTorque( self.__bpointer__(), vec[0], vec[1], vec[2] )
	def addRelTorque(self, vec):
		dBodyAddRelTorque( self.__bpointer__(), vec[0], vec[1], vec[2] )
	def getPosition(self):
		p = dBodyGetPosition( self.__bpointer__() )
		return vec3(p[0], p[1], p[2])
	def setRotation(self, qd):
		dQuaternion q
		q[0] = qd[3]
		q[1] = qd[0]
		q[2] = qd[1]
		q[3] = qd[2]
		#dBodySetQuaternion( self.__bpointer__(), q )
		dMatrix3 r
		dRfromQ( r, q )
		dBodySetRotation( self.__bpointer__(), r )
	def getRotation(self):
		#print(self.__bpointer__())
		#ptr = self.__bpointer__()
		#std::cout << "RAW: " << ptr->q[0] << ',' << ptr->q[1] << ','<< ptr->q[2] << ','<< ptr->q[3] << std::endl;
		#p = dBodyGetQuaternion( self.__bpointer__() )
		# note dQfromR is declared in ode_rotation.hpp
		dQuaternion p
		dQfromR( p, dBodyGetRotation( self.__bpointer__() ) )
		x = p[1]
		y = p[2]
		z = p[3]
		w = p[0]
		#return quat(p[1], p[2], p[3], p[0])
		return quat(x,y,z, w)
		#dBodyCopyQuaternion( self.__bpointer__(), q )		
		#return quat(q[1], q[2], q[3], q[0])
	def getLinearVel(self):
		p = dBodyGetLinearVel( self.__bpointer__() )
		return vec3(p[0], p[1], p[2])
	def getAngularVel(self):
		p = dBodyGetAngularVel( self.__bpointer__() )
		return vec3(p[0], p[1], p[2])
	def __init__(self, w):
		self.__bptr__ = dBodyCreate( w.__wpointer__() )


class space( object ):
	def __spointer__(self) ->dxSpace*:
		return unwrap(dxSpace, self.__sptr__)
	def releaseContactJoints(self):
		global __has_contacts__
		if __has_contacts__:
			dJointGroupEmpty(__contactgroup__)
			__has_contacts__ = false
	def spaceCollide(self):
		self.releaseContactJoints()
		dSpaceCollide( self.__spointer__(), 0, &__nearCallback)
	def __init__(self):
		self.__sptr__ = dSimpleSpaceCreate(0)


class __ode_geom_base__( object ):
	def __gpointer__(self) ->dxGeom*:
		return unwrap(dxGeom, self.__gptr__)
	def setBody(self, b):
		dGeomSetBody( self.__gpointer__(), b.__bpointer__())
	def __init__(self):
		self.__gptr__ = None


class geomPlane( __ode_geom_base__ ):
	def __init__(self, sp, nor, dist):
		self.__gptr__ = dCreatePlane( sp.__spointer__(), nor[0], nor[1], nor[2], dist)

class geomBox( __ode_geom_base__ ):
	def __init__(self, sp, bx):
		self.__gptr__ = dCreateBox( sp.__spointer__(), bx[0], bx[1], bx[2])










